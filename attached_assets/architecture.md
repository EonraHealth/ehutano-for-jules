# ehutano+ Full Stack Architecture Blueprint

This document outlines the proposed full-stack architecture for the ehutano+ platform, integrating frontend, backend, database, and authentication components. It draws heavily from the provided "ehutano+ Backend Development Plan & Architectural Blueprint."

## 1. Overall Architecture Style

The backend will adopt a **Modular Monolith** approach as specified in the blueprint. This means the application will be a single deployable unit, but internally structured into distinct modules. The frontend will likely be a **Single Page Application (SPA)** that communicates with the backend via APIs.

## 2. Technology Stack

| Component       | Technology/Framework                | Rationale (from blueprint or common practice)                                                                 |
|-----------------|-------------------------------------|-------------------------------------------------------------------------------------------------------------|
| **Frontend** | React (Recommended) or Vue.js/Angular | Modern, component-based SPA frameworks for building interactive UIs. (Frontend tech not specified in blueprint, React is a popular choice) |
| **Backend** | Python with FastAPI                 | High performance, built-in data validation, auto API docs, asynchronous. (As per blueprint)                 |
| **Database** | PostgreSQL                          | Robust, open-source RDBMS with strong support for complex queries and data integrity. (As per blueprint)      |
| **ORM** | SQLAlchemy (async version)          | Powerful and flexible database interaction, integrates with Pydantic. (As per blueprint)                      |
| **Authentication**| JWT (JSON Web Tokens)               | Stateless authentication, suitable for APIs. (As per blueprint)                                             |
| **Deployment** | Docker                              | Containerization for consistent environments and easier deployment. (As per blueprint)                        |
| **API Specs** | OpenAPI                             | Auto-generated by FastAPI for clear API documentation. (As per blueprint)                                   |

## 3. File and Folder Structure

This is a proposed high-level structure. Specific project needs might lead to variations.

ehutano-plus/├── frontend/                     # Frontend Application (e.g., React)│   ├── public/                   # Static assets (index.html, favicons, etc.)│   ├── src/                      # Frontend source code│   │   ├── assets/               # Images, fonts, global styles│   │   ├── components/           # Reusable UI components (buttons, inputs, cards)│   │   │   ├── common/           # General purpose components│   │   │   └── layout/           # Layout components (Navbar, Sidebar, Footer)│   │   ├── features/             # Feature-specific modules/components│   │   │   ├── auth/             # Login, registration, profile components│   │   │   ├── patient-portal/│   │   │   ├── pharmacy-portal/│   │   │   └── ...               # Other portals/features│   │   ├── contexts/             # React Context for global state (or state management folder like store/ for Redux/Zustand)│   │   ├── hooks/                # Custom React hooks│   │   ├── pages/                # Top-level page components (routed components)│   │   ├── services/             # API call handlers, utility functions│   │   │   ├── authService.js│   │   │   └── api.js            # Axios or Fetch instance configuration│   │   ├── routes/               # Routing configuration│   │   ├── utils/                # Utility functions (formatters, validators)│   │   ├── App.js                # Main application component│   │   └── index.js              # Entry point of the React app│   ├── package.json│   └── ...                       # Other config files (babel, eslint, prettier)│├── backend/                      # Backend Application (FastAPI)│   ├── app/                      # Main application package│   │   ├── api/                  # API Routers (endpoints)│   │   │   ├── v1/               # API version 1│   │   │   │   ├── auth.py│   │   │   │   ├── patient_portal.py│   │   │   │   ├── pharmacy_portal.py│   │   │   │   ├── doctor_portal.py│   │   │   │   ├── wholesaler_portal.py│   │   │   │   ├── wellness_hub.py│   │   │   │   └── init.py│   │   │   └── init.py│   │   ├── core/                 # Core components (config, security, db session)│   │   │   ├── config.py│   │   │   ├── security.py       # JWT handling, password hashing│   │   │   └── init.py│   │   ├── crud/                 # CRUD operations (data access logic, interacts with models)│   │   │   ├── crud_user.py│   │   │   ├── crud_medicine.py│   │   │   └── ...│   │   │   └── init.py│   │   ├── db/                   # Database setup and session management│   │   │   ├── base.py           # Base for SQLAlchemy models, common columns│   │   │   ├── session.py│   │   │   └── init.py│   │   ├── models/               # SQLAlchemy ORM models (database table definitions)│   │   │   ├── user.py│   │   │   ├── medicine.py│   │   │   ├── prescription.py│   │   │   └── ...│   │   │   └── init.py│   │   ├── schemas/              # Pydantic models (data validation, request/response shapes)│   │   │   ├── user.py│   │   │   ├── token.py│   │   │   └── ...│   │   │   └── init.py│   │   ├── services/             # Business logic layer (orchestrates CRUD and other operations)│   │   │   ├── user_service.py│   │   │   ├── order_service.py│   │   │   └── ...│   │   │   └── init.py│   │   ├── utils/                # Utility functions, enums, constants│   │   │   ├── enums.py│   │   │   └── init.py│   │   ├── main.py               # FastAPI application instance and main setup│   │   └── init.py│   ├── tests/                    # Unit and integration tests│   │   ├── conftest.py│   │   └── ...│   ├── alembic/                  # Database migration scripts (if using Alembic)│   ├── .env                      # Environment variables (ignored by git)│   ├── .gitignore│   ├── Dockerfile│   ├── requirements.txt│   └── README.md│├── docker-compose.yml            # For local development and multi-container setup└── README.md                     # Project-level README
## 4. Component Breakdown and Responsibilities

### 4.1. Frontend (e.g., React SPA)

* **`public/`**: Contains the main `index.html` file that hosts the SPA, along with other static assets like favicons or manifest files.
* **`src/assets/`**: Stores static assets like images, fonts, and global CSS/SCSS files.
* **`src/components/`**:
    * **`common/`**: Small, reusable UI components used across multiple features (e.g., `Button`, `Input`, `Modal`, `Spinner`).
    * **`layout/`**: Components defining the overall structure of the application (e.g., `Navbar`, `Sidebar`, `Footer`, `MainLayout`).
* **`src/features/` (or `src/modules/`)**: Organizes code by application feature or domain. Each feature folder would contain its specific components, hooks, and potentially services.
    * Example: `features/patient-portal/` might contain `Dashboard.js`, `PrescriptionList.js`, `UploadPrescriptionForm.js`.
* **`src/contexts/` or `src/store/`**:
    * **State Management**: Holds global application state. For React, this could be React Context API for simpler state or libraries like Redux, Zustand, or Recoil for more complex state management. This includes user authentication status, user profile, shopping cart, etc.
* **`src/hooks/`**: Custom React Hooks to encapsulate reusable logic (e.g., `useAuth`, `useFetchData`).
* **`src/pages/`**: Top-level components that are mapped to specific routes. They compose various smaller components and feature modules to build a complete view.
* **`src/services/`**:
    * **API Service/Integration**: Modules responsible for making API calls to the backend. Typically includes a configured HTTP client (e.g., Axios) and functions for each endpoint (e.g., `authService.js`, `medicineService.js`).
* **`src/routes/`**: Defines the application's routing configuration, mapping URLs to specific page components. Often uses a library like `react-router-dom`.
* **`src/utils/`**: General utility functions (e.g., date formatting, input validation helpers, constants).
* **`App.js`**: The root component of the React application, setting up routing, global context providers, and main layout.
* **`index.js`**: The entry point that renders the `App` component into the DOM.

### 4.2. Backend (FastAPI)

* **`app/api/`**:
    * **API Layer (Routers/Endpoints)**: Defines the HTTP endpoints. Each module (e.g., `auth.py`, `patient_portal.py`) contains FastAPI `APIRouter` instances with path operations (e.g., `@router.get("/users")`). These handle incoming requests, validate them using Pydantic schemas, and call service layer functions.
* **`app/core/`**:
    * **Configuration (`config.py`)**: Manages application settings (database URL, secret keys, etc.), often loaded from environment variables.
    * **Security (`security.py`)**: Handles security-related aspects like password hashing, JWT creation and decoding, and dependency injections for authentication.
* **`app/crud/`**:
    * **Data Access Layer (CRUD Operations)**: Contains functions that directly interact with the database via the ORM (SQLAlchemy). These functions perform Create, Read, Update, and Delete operations on database models. For example, `crud_user.get_user_by_email(db, email)`.
* **`app/db/`**:
    * **Database Setup & Session**: Initializes the database connection, defines the SQLAlchemy base for models, and manages database sessions (e.g., providing a `get_db` dependency for FastAPI).
* **`app/models/`**:
    * **SQLAlchemy ORM Models**: Python classes that define the structure of database tables and their relationships (e.g., `User`, `Medicine`, `Order`). These are derived from the database schema in the blueprint.
* **`app/schemas/`**:
    * **Pydantic Models**: Python classes used for data validation and serialization/deserialization of request and response bodies. They define the expected structure and types of data exchanged with the API.
* **`app/services/`**:
    * **Service Layer (Business Logic)**: Contains the core business logic of the application. Service functions orchestrate calls to CRUD functions, implement complex operations, interact with other services, and enforce business rules. For example, a `place_order` service might validate inventory, create an order record, and trigger a notification.
* **`app/utils/`**:
    * **Shared Utilities**: Common utility functions, enums, constants, or helper classes used across the backend.
* **`app/main.py`**: The main entry point for the FastAPI application. It initializes the FastAPI app instance, includes API routers, sets up middleware, and configures event handlers (startup/shutdown).
* **`tests/`**: Contains unit tests (for services, utils, CRUD operations) and integration tests (for API endpoints). Pytest is a common choice.
* **`alembic/`**: (If using Alembic) Stores database migration scripts to manage changes to the database schema over time.

### 4.3. Database (PostgreSQL)

* **Responsibilities**:
    * Persistently stores all application data (users, medicines, orders, prescriptions, etc.) as defined in the schema (see blueprint section 3).
    * Ensures data integrity through constraints, relationships, and transactions.
    * Handles complex queries and data retrieval.
* **Interaction**: The backend's Data Access Layer (SQLAlchemy models and CRUD functions) interacts directly with PostgreSQL.

### 4.4. Authentication (JWT)

* **Token Generation**: Upon successful login, the backend's auth service generates a JWT containing user identifiers and permissions (roles).
* **Token Transmission**: The JWT is sent to the frontend, which typically stores it (e.g., in `localStorage`, `sessionStorage`, or a secure cookie).
* **Token Validation**: For protected backend routes, the frontend includes the JWT in the `Authorization` header of API requests. The backend validates the token (signature, expiry) to authenticate the user and authorize access based on roles/permissions.
* **Statelessness**: JWTs enable stateless authentication, meaning the backend doesn't need to store session information for each user.

## 5. State Management

### 5.1. Frontend State

* **Local Component State**: Managed within individual React components using `useState` or `useReducer` for UI-specific data that doesn't need to be shared.
* **Global Application State**: For data shared across multiple components or the entire application:
    * **React Context API**: Suitable for simpler global state (e.g., theme, user authentication status).
    * **Dedicated State Management Libraries (Redux, Zustand, Recoil)**: For more complex state, offering advanced features like middleware, devtools, and optimized re-renders. This would manage things like user profile, shopping cart data, global notifications, etc.
* **Server Cache State / Fetched Data**: Libraries like React Query or SWR are often used to manage the state of data fetched from the backend, handling caching, background updates, and optimistic updates.

### 5.2. Backend State

* **Primarily Stateless**: The backend API (FastAPI) is designed to be stateless, especially when using JWT for authentication. Each request from the client contains all necessary information (including the JWT) for the server to process it.
* **Persistent State**: All long-term application state is stored in the **PostgreSQL database**.
* **Temporary/Cache State**: Optionally, a caching layer (e.g., Redis) can be introduced to store frequently accessed data or results of expensive computations to improve performance. This is not explicitly in the blueprint but is a common addition.

## 6. Service Connection / Data Flow

1.  **User Interaction (Frontend)**: The user interacts with the UI (e.g., clicks a button to log in or fetch medicines).
2.  **Frontend Request**:
    * The frontend (React component) triggers a function in its service layer (`authService.login()`, `medicineService.getMedicines()`).
    * This service function constructs an HTTP request (e.g., GET, POST) to the appropriate backend API endpoint (e.g., `/api/v1/auth/login`, `/api/v1/patient/medicines`).
    * If the endpoint is protected, the JWT (if available) is included in the `Authorization` header.
3.  **Backend Processing (FastAPI)**:
    * The FastAPI router receives the request and directs it to the corresponding path operation function in an API module (e.g., `app.api.v1.auth.login_user`).
    * **Authentication/Authorization**: If the route is protected, a dependency (e.g., `get_current_user`) validates the JWT and retrieves user information.
    * **Request Validation**: Pydantic schemas validate the request body or query parameters.
    * **Service Layer Call**: The API endpoint function calls the relevant function in the service layer (e.g., `user_service.authenticate_user(...)`, `medicine_service.get_available_medicines(...)`).
    * **Business Logic (Service Layer)**: The service function executes the business logic. This may involve:
        * Calling one or more CRUD functions to interact with the database.
        * Performing calculations or transformations.
        * Interacting with other services (if any).
    * **Data Access (CRUD Layer & SQLAlchemy)**: CRUD functions use SQLAlchemy models to query or modify data in the PostgreSQL database.
    * **Database Interaction**: SQLAlchemy translates Python calls into SQL queries, which are executed by PostgreSQL. The database returns data or confirms changes.
4.  **Backend Response**:
    * The service layer returns results (or errors) to the API layer.
    * The API layer constructs an HTTP response, serializing data using Pydantic schemas if necessary.
5.  **Frontend Receives Response**:
    * The frontend API service receives the HTTP response.
    * It processes the response (e.g., parses JSON, handles errors).
    * The data is then used to update the frontend state (local or global).
6.  **UI Update (Frontend)**: React detects state changes and re-renders the relevant components to reflect the new data or UI state.

**Example Flow: User Login**

1.  User enters credentials in a React login form and clicks "Login".
2.  `LoginPage` component calls `authService.login(email, password)`.
3.  `authService` POSTs to `/api/v1/auth/login` with credentials.
4.  FastAPI `auth.py` router receives the request.
5.  Calls `user_service.authenticate_user(db, email, password)`.
6.  `user_service` calls `crud_user.get_user_by_email(db, email)`.
7.  `crud_user` queries PostgreSQL via SQLAlchemy.
8.  If user exists and password matches (after hashing comparison), `user_service` generates a JWT using `security.create_access_token()`.
9.  JWT is returned to `auth.py`, then to the frontend.
10. Frontend `authService` stores the JWT and updates global auth state (e.g., in React Context).
11. UI re-renders to show the authenticated state (e.g., navigates to dashboard).

## 7. Deployment Considerations (from Blueprint)

* **Docker**: The application (frontend and backend) will be containerized using Docker. This ensures consistency across development, testing, and production environments.
* **`docker-compose.yml`**: Can be used to define and run multi-container Docker applications (e.g., frontend container, backend container, PostgreSQL container) for local development and testing.
* **Production Deployment**: While not fully detailed, Docker containers can be deployed to various platforms (cloud providers like AWS, Azure, GCP, or on-premise servers) using orchestration tools like Kubernetes or simpler PaaS solutions.

This architecture provides a solid foundation for building ehutano+. The modular design in both frontend and backend will facilitate development, testing, and maintenance.
